---
title: 使用分治+递归简化问题求解
date: 2021-04-20 17:15:45
description: 使用分治+递归简化问题求解
categories:
  - [算法,分治]
tags:
  - 分治法
  - 递归思想
keywords: SpringClond
copyright_author: Monster
cover: https://raw.githubusercontent.com/MyMonsterCat/md_image/main/%E5%9F%BA%E7%A1%80/Blog_Cover/10.jpg
---

# 使用分治+递归简化问题求解	

​	上次我们说到了求最大的连续子区间问题常用的解决方案——滑动窗口，并使用数据结构+滑动窗口解决更复杂的问题，今天借着复习使用滑动窗口，我们再来学点新知识。话不多说，上题目~

## 一、例题

​	给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。

**示例** 

> 输入：s = "aaabb", k = 3
> 输出：3
> 解释：最长子串为 "aaa" ，其中 'a' 重复了 3 次。
>
> 输入：s = "ababbc", k = 2
> 输出：5
> 解释：最长子串为 "ababb" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。。

**提示：**

- 1 <= s.length <= 104
- s 仅由小写英文字母组成
- 1 <= k <= 105

### 题目分析

​	显而易见，求最大连续子区间的长度，题目说明了只包含小写字母（26 个，为有限数据），我们可以枚举最大长度所包含的字符类型数量，答案必然是 [1, 26]，即最少包含 1 个字母，最多包含 26 个字母，化简问题为26个子问题， 当只有N个字母，每个字母都出现至少k次时的最长串。

​	首先我们想到的就是使用滑动窗口来解决，对于特定的字符种类数量 `t`，我们维护滑动窗口的左右边界 `l`和`r` 。滑动窗口内部每个字符出现的次数 `cnt`，以及滑动窗口内的字符种类数目 `total`。当 `total` >`t` 时，我们不断地右移左边界，并对应地更新 `cnt` 以及`total`，直到 `total` ≤ `t` 为止。

但是题目中要求**该子串中的每一字符出现次数都不少于 k**，如何才能做到这点呢？

- 直接遍历，每次遍历窗口中的元素，统计出现次数

- 维护一个计数器，用来记录**当前出现次数小于 k 的字符的数量**，由于每次移动滑动窗口的边界时，只会让某个字符的出现次数加一或者减一。

  所以对于移动左右指针的情况而言，有且仅有两种情况

  ​	①当某个字符的出现次数从 0 增加到 1 时，将 计数器加一

  ​	②当某个字符的出现次数从 k-1增加到 k时，将 计数器减一   
  
### 代码实现

```java
class Solution {
    public int longestSubstring(String s, int k) {
        int ret = 0;//符合条件子串的长度
        int n = s.length();
        for (int t = 1; t <= 26; t++) {//小于字符集大小
            int l = 0, r = 0;//定义左右指针
            int[] cnt = new int[26];//滑动窗口内部每个字符出现的次数
            int tot = 0;//滑动窗口内的字符种类数目
            int less = 0;//定义计数器
            while (r < n) {//右指针主动右移
                cnt[s.charAt(r) - 'a']++;
                // 如果某个字符出现（出现次数从 0 增加到 1 ）
                if (cnt[s.charAt(r) - 'a'] == 1) {
                    tot++;
                    less++;
                }
                // 如果某个字符串出现次数从k-1增加到 k
                if (cnt[s.charAt(r) - 'a'] == k) {
                    less--;
                }
				// 当窗口内的总数大于字符集的大小
                while (tot > t) {
                    cnt[s.charAt(l) - 'a']--;
                    if (cnt[s.charAt(l) - 'a'] == k - 1) {
                        less++;
                    }
                    if (cnt[s.charAt(l) - 'a'] == 0) {
                        tot--;
                        less--;
                    }
                    l++;
                }
                // 当出现次数小于 k 的字符的数量为0
                if (less == 0) {
                    ret = Math.max(ret, r - l + 1);
                }
                r++;
            }
        }
        return ret;
    }
}
```

​	可以看出，本题使用滑动窗口反而让问题解决变得更复杂，更容易出错更难理解了，下面我们来介绍一种新的方法

## 二、使用分治 + 递归

### 什么是分治

​	在使用分治之前，我们先来了解一下什么是分治，字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。

​	如果原问题可分割成k个子问题，1<k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。

​	**分治是一种思想，它不涉及到具体的算法，而大多数情况下，分治都是借由递归来实现的。**

### 分治适用情况

  1) 该问题的规模缩小到一定的程度就可以容易地解决

  2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。

  3) 利用该问题分解出的子问题的解可以合并为该问题的解；

  4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。



第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；

**第二条特征是应用分治法的前提**它也是大多数问题可以满足的，此特征反映了递归思想的应用；

**第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征**，如果**具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法**。

**第四条特征涉及到分治法的效率**，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但**一般用动态规划法较好**。

### 分治法的基本步骤

分治法在每一层递归上都有三个步骤：

   **分解**：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；

   **解决**：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题

   **合并**：将各个子问题的解合并为原问题的解。

它的一般的算法设计模式如下

|                    步骤                     |                             说明                             |
| :-----------------------------------------: | :----------------------------------------------------------: |
|               if \|P\| ≤ n~0~               | \|P\| 表示问题P的规模<br/>n~0~为一阈值，表示当问题P的规模不超过n~0~时，问题已容易直接解出，不必再继续分解 |
|            then return(ADHOC(P))            | ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P，当P的规模不超过n0时直接用算法ADHOC(P)求解。 |
|    将P分解为较小的子问题 P1 ,P2 ,...,Pk     |                                                              |
|                for i←1 to k                 |                                                              |
| do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi |                                                              |
|    T ← MERGE(y1,y2,...,yk) △ 合并子问题     | 算法MERGE(y1，y2，...，yk)是该分治法中的合并子算法，用于将P的子问题P1 ，P2 ，...，Pk的相应的解y1，y2，...，yk合并为P的解。 |
|                  return(T)                  |                                                              |

###  可使用分治法求解的一些经典问题

|     二分搜索     |  大整数乘法  |
| :--------------: | :----------: |
| Strassen矩阵乘法 |   棋盘覆盖   |
|     合并排序     |   快速排序   |
|     快速排序     | 线性时间选择 |
|  最接近点对问题  | 循环赛日程表 |
|   循环赛日程表   |    汉诺塔    |

### 分治的典型实现：二分搜索法

又叫做二分查找，折半查找，它是一种效率较高的查找方法。

线性表为有序表，先确定待查找记录所在的范围，然后逐步缩小范围直至找到或找不到该记录的位置。

- 先确定中间位置： ![[公式]](https://www.zhihu.com/equation?tex=middle%3D%28left%2Bright%29%2F2) ;

- 将待查找的key值与`data[middle].key`的值比较，相等则查找成功并返回该位置，否则须确定新得查找区间，继续二分查找，

- - 如果`data[middle].key`大于key，由于data为有序线性表，可知`data[middle...right].key`均大于key，因此若表中存在关键字等于key的节点，则一定在位置middle左边的子表中。
  - 反之，`data[middle].key`小于key，若表中存在关键字等于key的节点，则一定在位置middle右边的子表中，下一次查找对新的区域进行查找。

### 使用分治思想+递归算法解决例题

​	对于字符串 s，如果存在某个字符 ch，它的出现次数大于 0 且小于 k，则**任何包含 ch 的子串都不可能满足要求**。也就是说，我们将字符串按照 ch 切分成若干段，则满足要求的最长子串一定出现在某个被切分的段内，而不能跨越一个或多个段。因此，可以考虑分治的方式求解本题

下面是详细讲解

- **递归最基本的是记住递归函数的含义（务必牢记函数定义**）：本题的 longestSubstring(s, k) 函数表示的就是题意，即求一个最长的子字符串的长度，该子字符串中每个字符出现的次数都最少为 k。函数入参 s 是表示源字符串；kk 是限制条件，即子字符串中每个字符最少出现的次数；函数返回结果是满足题意的最长子字符串长度。

- **递归的终止条件（能直接写出的最简单 case）**：如果字符串 s 的长度少于 k，那么一定不存在满足题意的子字符串，返回 0；

- **调用递归（重点）**：如果一个字符 c 在 s 中出现的次数少于 k 次，那么 s 中所有的包含 c 的子字符串都不能满足题意。所以，应该在 s 的所有不包含 c 的子字符串中继续寻找结果：把 s 按照 c 分割（分割后每个子串都不包含 c），得到很多子字符串 t；下一步要求 t 作为源字符串的时候，它的最长的满足题意的子字符串长度（到现在为止，我们把大问题分割为了小问题(s → t)）。此时我们发现，恰好已经定义了函数 longestSubstring(s, k) 就是来解决这个问题的！所以直接把 longestSubstring(s, k) 函数拿来用，于是形成了递归。

- **未进入递归时的返回结果**：如果 s 中的每个字符出现的次数都大于 k 次，那么 s 就是我们要求的字符串，直接返回该字符串的长度。

​		总之，通过上面的分析，我们看出了：我们不是为了递归而递归。而是因为我们把大问题拆解成了小问题，恰好有函数可以解决小问题，所以直接用这个函数。由于这个函数正好是本身，所以我们把此现象叫做递归。**小问题是原因，递归是结果**。而递归函数到底怎么一层层展开与终止的，不要用大脑去想，这是计算机干的事。我们只用把递归函数当做一个能解决问题的黑箱就够了，把更多的注意力放在拆解子问题、递归终止条件、递归函数的正确性上来。

```java
class Solution {
    public int longestSubstring(String s, int k) {
        if (s.length() < k) return 0;
        HashMap<Character, Integer> counter = new HashMap();
        for (int i = 0; i < s.length(); i++) {
            counter.put(s.charAt(i), counter.getOrDefault(s.charAt(i), 0) + 1);
        }
        for (char c : counter.keySet()) {
            if (counter.get(c) < k) {
                int res = 0;
                for (String t : s.split(String.valueOf(c))) {
                    res = Math.max(res, longestSubstring(t, k));
                }
                return res;
            }
        }
        return s.length();
    }
}
```

**抛砖引玉**：在分支的过程中可以加适当的剪枝，比如在s: aaabbaa,k: 3中，b 只出现 2 次，它肯定不会出现在合法子串中，要到它的两侧找。



